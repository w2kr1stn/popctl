"""Unit tests for the exchange module.

Tests for the file exchange logic that handles communication between
popctl and AI advisors via scan.json and decisions.toml files.
"""

from __future__ import annotations

import json
from pathlib import Path

import pytest
from popctl.advisor.exchange import (
    DecisionsResult,
    PackageDecision,
    PackageScanEntry,
    ScanExport,
    SourceDecisions,
    cleanup_exchange_dir,
    export_prompt_files,
    export_scan_for_advisor,
    get_decisions_path,
    get_scan_json_path,
    import_decisions,
)
from popctl.models.package import PackageSource, PackageStatus, ScannedPackage
from popctl.models.scan_result import ScanResult

# =============================================================================
# Test Fixtures
# =============================================================================


@pytest.fixture
def sample_packages() -> list[ScannedPackage]:
    """Create sample packages for testing."""
    return [
        ScannedPackage(
            name="firefox",
            source=PackageSource.APT,
            version="128.0",
            status=PackageStatus.MANUAL,
            description="Mozilla Firefox web browser",
            size_bytes=204800,
        ),
        ScannedPackage(
            name="libgtk-3-0",
            source=PackageSource.APT,
            version="3.24.41",
            status=PackageStatus.AUTO_INSTALLED,
            description="GTK graphical toolkit",
            size_bytes=10240,
        ),
        ScannedPackage(
            name="com.spotify.Client",
            source=PackageSource.FLATPAK,
            version="1.2.31",
            status=PackageStatus.MANUAL,
            description="Music streaming service",
            size_bytes=1073741824,
        ),
    ]


@pytest.fixture
def sample_scan_result(sample_packages: list[ScannedPackage]) -> ScanResult:
    """Create sample ScanResult for testing."""
    return ScanResult.create(
        packages=sample_packages,
        sources=["apt", "flatpak"],
        manual_only=False,
    )


@pytest.fixture
def valid_decisions_toml() -> str:
    """Valid decisions.toml content for testing."""
    return """
# Generated by AI Advisor
# Date: 2026-01-25T12:00:00Z

[packages.apt]
keep = [
    { name = "firefox", reason = "Web browser", confidence = 0.95, category = "desktop" },
    { name = "libgtk-3-0", reason = "GUI library", confidence = 0.98, category = "system" },
]
remove = [
    { name = "apport", reason = "Telemetry", confidence = 0.92, category = "telemetry" },
]
ask = [
    { name = "gcc", reason = "Dev tools", confidence = 0.65, category = "development" },
]

[packages.flatpak]
keep = [
    { name = "com.spotify.Client", reason = "Music app", confidence = 0.90, category = "media" },
]
remove = []
ask = []
"""


@pytest.fixture
def invalid_category_toml() -> str:
    """decisions.toml with invalid category."""
    return """
[packages.apt]
keep = [
    { name = "test", reason = "test", confidence = 0.95, category = "invalid_category" },
]
remove = []
ask = []

[packages.flatpak]
keep = []
remove = []
ask = []
"""


@pytest.fixture
def invalid_toml_syntax() -> str:
    """Invalid TOML syntax for testing."""
    return """
[packages.apt
keep = [
    { name = "test", reason = "test"
]
"""


# =============================================================================
# Test PackageScanEntry Model
# =============================================================================


class TestPackageScanEntry:
    """Tests for PackageScanEntry Pydantic model."""

    def test_create_entry_with_all_fields(self) -> None:
        """PackageScanEntry accepts all fields."""
        entry = PackageScanEntry(
            name="firefox",
            source="apt",
            version="128.0",
            status="manual",
            description="Web browser",
            size_bytes=204800,
        )

        assert entry.name == "firefox"
        assert entry.source == "apt"
        assert entry.version == "128.0"
        assert entry.status == "manual"
        assert entry.description == "Web browser"
        assert entry.size_bytes == 204800

    def test_create_entry_with_minimal_fields(self) -> None:
        """PackageScanEntry works with minimal required fields."""
        entry = PackageScanEntry(
            name="test",
            source="apt",
            version="1.0",
            status="manual",
        )

        assert entry.name == "test"
        assert entry.description is None
        assert entry.size_bytes is None

    def test_entry_is_frozen(self) -> None:
        """PackageScanEntry is immutable."""
        entry = PackageScanEntry(
            name="test",
            source="apt",
            version="1.0",
            status="manual",
        )

        from pydantic import ValidationError

        with pytest.raises(ValidationError):  # Pydantic frozen models raise ValidationError
            entry.name = "changed"  # type: ignore[misc]


# =============================================================================
# Test ScanExport Model
# =============================================================================


class TestScanExport:
    """Tests for ScanExport Pydantic model."""

    def test_create_scan_export(self) -> None:
        """ScanExport accepts complete data."""
        entries = [
            PackageScanEntry(
                name="firefox",
                source="apt",
                version="128.0",
                status="manual",
            )
        ]

        export = ScanExport(
            scan_date="2026-01-25T12:00:00Z",
            system={"hostname": "test-host", "os": "Pop!_OS 24.04 LTS"},
            summary={"total_packages": 1, "manual_apt": 1},
            packages={"unknown": entries, "new_since_manifest": []},
        )

        assert export.scan_date == "2026-01-25T12:00:00Z"
        assert export.system["hostname"] == "test-host"
        assert export.summary["total_packages"] == 1
        assert len(export.packages["unknown"]) == 1


# =============================================================================
# Test PackageDecision Model
# =============================================================================


class TestPackageDecision:
    """Tests for PackageDecision Pydantic model."""

    def test_create_valid_decision(self) -> None:
        """PackageDecision accepts valid data."""
        decision = PackageDecision(
            name="firefox",
            reason="Web browser needed",
            confidence=0.95,
            category="desktop",
        )

        assert decision.name == "firefox"
        assert decision.reason == "Web browser needed"
        assert decision.confidence == 0.95
        assert decision.category == "desktop"

    def test_decision_validates_confidence_range(self) -> None:
        """PackageDecision validates confidence is between 0.0 and 1.0."""
        # Valid boundary values
        PackageDecision(name="test", reason="test", confidence=0.0, category="system")
        PackageDecision(name="test", reason="test", confidence=1.0, category="system")

        # Invalid values
        with pytest.raises(ValueError):
            PackageDecision(name="test", reason="test", confidence=-0.1, category="system")

        with pytest.raises(ValueError):
            PackageDecision(name="test", reason="test", confidence=1.1, category="system")

    def test_decision_validates_category(self) -> None:
        """PackageDecision validates category against CATEGORIES."""
        from popctl.advisor.prompts import CATEGORIES

        # Valid categories
        for cat in CATEGORIES:
            decision = PackageDecision(name="test", reason="test", confidence=0.5, category=cat)
            assert decision.category == cat

        # Invalid category
        with pytest.raises(ValueError, match="Invalid category"):
            PackageDecision(name="test", reason="test", confidence=0.5, category="invalid_cat")


# =============================================================================
# Test SourceDecisions Model
# =============================================================================


class TestSourceDecisions:
    """Tests for SourceDecisions Pydantic model."""

    def test_source_decisions_defaults_to_empty_lists(self) -> None:
        """SourceDecisions defaults to empty lists."""
        decisions = SourceDecisions()

        assert decisions.keep == []
        assert decisions.remove == []
        assert decisions.ask == []

    def test_source_decisions_accepts_lists(self) -> None:
        """SourceDecisions accepts decision lists."""
        keep = [
            PackageDecision(name="pkg1", reason="r1", confidence=0.95, category="system"),
        ]
        remove = [
            PackageDecision(name="pkg2", reason="r2", confidence=0.90, category="telemetry"),
        ]

        decisions = SourceDecisions(keep=keep, remove=remove)

        assert len(decisions.keep) == 1
        assert len(decisions.remove) == 1
        assert len(decisions.ask) == 0


# =============================================================================
# Test DecisionsResult Model
# =============================================================================


class TestDecisionsResult:
    """Tests for DecisionsResult Pydantic model."""

    def test_decisions_result_structure(self) -> None:
        """DecisionsResult has correct structure."""
        apt_decisions = SourceDecisions(
            keep=[PackageDecision(name="apt-pkg", reason="r", confidence=0.9, category="system")]
        )
        flatpak_decisions = SourceDecisions()

        result = DecisionsResult(
            packages={
                "apt": apt_decisions,
                "flatpak": flatpak_decisions,
            }
        )

        assert "apt" in result.packages
        assert "flatpak" in result.packages
        assert len(result.packages["apt"].keep) == 1


# =============================================================================
# Test export_scan_for_advisor
# =============================================================================


class TestExportScanForAdvisor:
    """Tests for export_scan_for_advisor function."""

    def test_export_creates_scan_json(self, tmp_path: Path, sample_scan_result: ScanResult) -> None:
        """export_scan_for_advisor creates scan.json file."""
        result_path = export_scan_for_advisor(sample_scan_result, tmp_path)

        assert result_path.exists()
        assert result_path.name == "scan.json"
        assert result_path.parent == tmp_path

    def test_export_creates_valid_json(
        self, tmp_path: Path, sample_scan_result: ScanResult
    ) -> None:
        """export_scan_for_advisor creates valid JSON."""
        result_path = export_scan_for_advisor(sample_scan_result, tmp_path)

        with result_path.open() as f:
            data = json.load(f)

        assert "scan_date" in data
        assert "system" in data
        assert "summary" in data
        assert "packages" in data

    def test_export_includes_all_packages(
        self, tmp_path: Path, sample_scan_result: ScanResult
    ) -> None:
        """export_scan_for_advisor includes all packages in unknown list."""
        result_path = export_scan_for_advisor(sample_scan_result, tmp_path)

        with result_path.open() as f:
            data = json.load(f)

        unknown_packages = data["packages"]["unknown"]
        assert len(unknown_packages) == 3

        names = {p["name"] for p in unknown_packages}
        assert "firefox" in names
        assert "libgtk-3-0" in names
        assert "com.spotify.Client" in names

    def test_export_includes_system_info(
        self, tmp_path: Path, sample_scan_result: ScanResult
    ) -> None:
        """export_scan_for_advisor includes system information."""
        result_path = export_scan_for_advisor(sample_scan_result, tmp_path)

        with result_path.open() as f:
            data = json.load(f)

        assert "hostname" in data["system"]
        assert "os" in data["system"]
        assert data["system"]["os"] == "Pop!_OS 24.04 LTS"

    def test_export_includes_manifest_path(
        self, tmp_path: Path, sample_scan_result: ScanResult
    ) -> None:
        """export_scan_for_advisor includes manifest_path when provided."""
        manifest_path = Path("/home/user/.config/popctl/manifest.toml")
        result_path = export_scan_for_advisor(
            sample_scan_result, tmp_path, manifest_path=manifest_path
        )

        with result_path.open() as f:
            data = json.load(f)

        assert "manifest_path" in data["system"]
        assert data["system"]["manifest_path"] == str(manifest_path)

    def test_export_calculates_summary(
        self, tmp_path: Path, sample_scan_result: ScanResult
    ) -> None:
        """export_scan_for_advisor calculates correct summary."""
        result_path = export_scan_for_advisor(sample_scan_result, tmp_path)

        with result_path.open() as f:
            data = json.load(f)

        summary = data["summary"]
        assert summary["total_packages"] == 3
        assert summary["manual_apt"] == 1  # firefox
        assert summary["auto_apt"] == 1  # libgtk-3-0
        assert summary["flatpak"] == 1  # spotify

    def test_export_creates_exchange_dir_if_not_exists(
        self, tmp_path: Path, sample_scan_result: ScanResult
    ) -> None:
        """export_scan_for_advisor creates exchange directory if needed."""
        exchange_dir = tmp_path / "nested" / "exchange"
        assert not exchange_dir.exists()

        result_path = export_scan_for_advisor(sample_scan_result, exchange_dir)

        assert exchange_dir.exists()
        assert result_path.exists()


# =============================================================================
# Test export_prompt_files
# =============================================================================


class TestExportPromptFiles:
    """Tests for export_prompt_files function."""

    def test_export_creates_prompt_txt(self, tmp_path: Path) -> None:
        """export_prompt_files creates prompt.txt."""
        prompt_path = export_prompt_files(tmp_path)

        assert prompt_path.exists()
        assert prompt_path.name == "prompt.txt"

    def test_export_returns_path(self, tmp_path: Path) -> None:
        """export_prompt_files returns Path (not tuple)."""
        result = export_prompt_files(tmp_path)

        assert isinstance(result, Path)

    def test_prompt_contains_file_paths(self, tmp_path: Path) -> None:
        """export_prompt_files includes correct file paths in prompt."""
        prompt_path = export_prompt_files(tmp_path)

        content = prompt_path.read_text()

        assert "scan.json" in content
        assert "decisions.toml" in content

    def test_prompt_contains_system_info(self, tmp_path: Path) -> None:
        """export_prompt_files includes system info in prompt."""
        prompt_path = export_prompt_files(tmp_path)

        content = prompt_path.read_text()

        # Should have hostname somewhere in the prompt
        import socket

        hostname = socket.gethostname()
        assert hostname in content

    def test_export_creates_dir_if_not_exists(self, tmp_path: Path) -> None:
        """export_prompt_files creates directory if needed."""
        exchange_dir = tmp_path / "new" / "dir"
        assert not exchange_dir.exists()

        export_prompt_files(exchange_dir)

        assert exchange_dir.exists()


# =============================================================================
# Test import_decisions
# =============================================================================


class TestImportDecisions:
    """Tests for import_decisions function."""

    def test_import_valid_decisions(self, tmp_path: Path, valid_decisions_toml: str) -> None:
        """import_decisions parses valid decisions.toml."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(valid_decisions_toml)

        result = import_decisions(tmp_path)

        assert isinstance(result, DecisionsResult)
        assert "apt" in result.packages
        assert "flatpak" in result.packages

    def test_import_parses_keep_list(self, tmp_path: Path, valid_decisions_toml: str) -> None:
        """import_decisions correctly parses keep list."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(valid_decisions_toml)

        result = import_decisions(tmp_path)

        apt_keep = result.packages["apt"].keep
        assert len(apt_keep) == 2

        firefox = next(d for d in apt_keep if d.name == "firefox")
        assert firefox.reason == "Web browser"
        assert firefox.confidence == 0.95
        assert firefox.category == "desktop"

    def test_import_parses_remove_list(self, tmp_path: Path, valid_decisions_toml: str) -> None:
        """import_decisions correctly parses remove list."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(valid_decisions_toml)

        result = import_decisions(tmp_path)

        apt_remove = result.packages["apt"].remove
        assert len(apt_remove) == 1
        assert apt_remove[0].name == "apport"
        assert apt_remove[0].category == "telemetry"

    def test_import_parses_ask_list(self, tmp_path: Path, valid_decisions_toml: str) -> None:
        """import_decisions correctly parses ask list."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(valid_decisions_toml)

        result = import_decisions(tmp_path)

        apt_ask = result.packages["apt"].ask
        assert len(apt_ask) == 1
        assert apt_ask[0].name == "gcc"
        assert apt_ask[0].confidence == 0.65

    def test_import_parses_flatpak_decisions(
        self, tmp_path: Path, valid_decisions_toml: str
    ) -> None:
        """import_decisions correctly parses flatpak section."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(valid_decisions_toml)

        result = import_decisions(tmp_path)

        flatpak_keep = result.packages["flatpak"].keep
        assert len(flatpak_keep) == 1
        assert flatpak_keep[0].name == "com.spotify.Client"
        assert flatpak_keep[0].category == "media"

    def test_import_raises_file_not_found(self, tmp_path: Path) -> None:
        """import_decisions raises FileNotFoundError if file missing."""
        with pytest.raises(FileNotFoundError, match="decisions.toml not found"):
            import_decisions(tmp_path)

    def test_import_raises_on_invalid_toml(self, tmp_path: Path, invalid_toml_syntax: str) -> None:
        """import_decisions raises ValueError on invalid TOML syntax."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(invalid_toml_syntax)

        with pytest.raises(ValueError, match="Invalid TOML"):
            import_decisions(tmp_path)

    def test_import_raises_on_invalid_category(
        self, tmp_path: Path, invalid_category_toml: str
    ) -> None:
        """import_decisions raises ValueError on invalid category."""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(invalid_category_toml)

        with pytest.raises(ValueError, match="Invalid category"):
            import_decisions(tmp_path)

    def test_import_handles_empty_lists(self, tmp_path: Path) -> None:
        """import_decisions handles empty decision lists."""
        decisions_toml = """
[packages.apt]
keep = []
remove = []
ask = []

[packages.flatpak]
keep = []
remove = []
ask = []
"""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(decisions_toml)

        result = import_decisions(tmp_path)

        assert result.packages["apt"].keep == []
        assert result.packages["apt"].remove == []
        assert result.packages["apt"].ask == []

    def test_import_handles_missing_source(self, tmp_path: Path) -> None:
        """import_decisions handles missing source sections."""
        decisions_toml = """
[packages.apt]
keep = []
remove = []
ask = []
# flatpak section missing
"""
        decisions_path = tmp_path / "decisions.toml"
        decisions_path.write_text(decisions_toml)

        result = import_decisions(tmp_path)

        # Should have empty flatpak decisions
        assert result.packages["flatpak"].keep == []
        assert result.packages["flatpak"].remove == []


# =============================================================================
# Test cleanup_exchange_dir
# =============================================================================


class TestCleanupExchangeDir:
    """Tests for cleanup_exchange_dir function."""

    def test_cleanup_removes_all_exchange_files(self, tmp_path: Path) -> None:
        """cleanup_exchange_dir removes all known exchange files."""
        # Create all exchange files
        (tmp_path / "scan.json").write_text("{}")
        (tmp_path / "decisions.toml").write_text("")
        (tmp_path / "prompt.txt").write_text("")

        cleanup_exchange_dir(tmp_path)

        assert not (tmp_path / "scan.json").exists()
        assert not (tmp_path / "decisions.toml").exists()
        assert not (tmp_path / "prompt.txt").exists()

    def test_cleanup_preserves_directory(self, tmp_path: Path) -> None:
        """cleanup_exchange_dir preserves the directory itself."""
        (tmp_path / "scan.json").write_text("{}")

        cleanup_exchange_dir(tmp_path)

        assert tmp_path.exists()
        assert tmp_path.is_dir()

    def test_cleanup_ignores_other_files(self, tmp_path: Path) -> None:
        """cleanup_exchange_dir ignores non-exchange files."""
        other_file = tmp_path / "other.txt"
        other_file.write_text("keep me")

        cleanup_exchange_dir(tmp_path)

        assert other_file.exists()
        assert other_file.read_text() == "keep me"

    def test_cleanup_handles_nonexistent_dir(self, tmp_path: Path) -> None:
        """cleanup_exchange_dir handles non-existent directory gracefully."""
        nonexistent = tmp_path / "nonexistent"

        # Should not raise
        cleanup_exchange_dir(nonexistent)

    def test_cleanup_handles_missing_files(self, tmp_path: Path) -> None:
        """cleanup_exchange_dir handles missing files gracefully."""
        # Only create some files
        (tmp_path / "scan.json").write_text("{}")

        # Should not raise even though other files don't exist
        cleanup_exchange_dir(tmp_path)

        assert not (tmp_path / "scan.json").exists()


# =============================================================================
# Test Path Helper Functions
# =============================================================================


class TestPathHelpers:
    """Tests for path helper functions."""

    def test_get_scan_json_path_with_dir(self, tmp_path: Path) -> None:
        """get_scan_json_path returns correct path when dir provided."""
        path = get_scan_json_path(tmp_path)

        assert path == tmp_path / "scan.json"

    def test_get_scan_json_path_default(self) -> None:
        """get_scan_json_path uses default exchange dir when not provided."""
        from popctl.core.paths import get_exchange_dir

        path = get_scan_json_path()

        assert path == get_exchange_dir() / "scan.json"

    def test_get_decisions_path_with_dir(self, tmp_path: Path) -> None:
        """get_decisions_path returns correct path when dir provided."""
        path = get_decisions_path(tmp_path)

        assert path == tmp_path / "decisions.toml"

    def test_get_decisions_path_default(self) -> None:
        """get_decisions_path uses default exchange dir when not provided."""
        from popctl.core.paths import get_exchange_dir

        path = get_decisions_path()

        assert path == get_exchange_dir() / "decisions.toml"


# =============================================================================
# Test Module Exports
# =============================================================================


class TestModuleExports:
    """Tests for module-level exports."""

    def test_exchange_module_exports(self) -> None:
        """exchange module exports expected symbols."""
        from popctl.advisor import exchange

        # Models
        assert hasattr(exchange, "PackageScanEntry")
        assert hasattr(exchange, "ScanExport")
        assert hasattr(exchange, "PackageDecision")
        assert hasattr(exchange, "SourceDecisions")
        assert hasattr(exchange, "DecisionsResult")

        # Functions
        assert hasattr(exchange, "export_scan_for_advisor")
        assert hasattr(exchange, "export_prompt_files")
        assert hasattr(exchange, "import_decisions")
        assert hasattr(exchange, "cleanup_exchange_dir")
        assert hasattr(exchange, "get_scan_json_path")
        assert hasattr(exchange, "get_decisions_path")

    def test_advisor_init_exports_exchange(self) -> None:
        """advisor __init__ exports exchange symbols."""
        from popctl.advisor import (
            DecisionsResult,
            PackageDecision,
            PackageScanEntry,
            ScanExport,
            SourceDecisions,
            cleanup_exchange_dir,
            export_prompt_files,
            export_scan_for_advisor,
            get_decisions_path,
            get_scan_json_path,
            import_decisions,
        )

        # Verify imports work and are callable/classes
        assert callable(export_scan_for_advisor)
        assert callable(export_prompt_files)
        assert callable(import_decisions)
        assert callable(cleanup_exchange_dir)
        assert callable(get_scan_json_path)
        assert callable(get_decisions_path)
        assert PackageScanEntry is not None
        assert ScanExport is not None
        assert PackageDecision is not None
        assert SourceDecisions is not None
        assert DecisionsResult is not None
