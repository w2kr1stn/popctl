"""Prompt templates for AI-assisted package classification.

This module provides prompt templates for the Claude Advisor to classify
packages as keep, remove, or ask. It supports both headless (autonomous)
and interactive modes.

Templates are based on the classification rules from SPEC.md Section 8.
"""

from datetime import UTC, datetime
from pathlib import Path

# =============================================================================
# decisions.toml Schema Reference
# =============================================================================
# The expected output format for AI classification:
#
# [packages.apt]
# keep = [
#     { name = "pkg", reason = "...", confidence = 0.95, category = "system" },
# ]
# remove = [
#     { name = "pkg", reason = "...", confidence = 0.92, category = "telemetry" },
# ]
# ask = [
#     { name = "pkg", reason = "...", confidence = 0.45, category = "development" },
# ]
#
# [packages.flatpak]
# keep = []
# remove = []
# ask = []
# =============================================================================

# Classification categories for packages
CATEGORIES = (
    "system",
    "desktop",
    "drivers",
    "development",
    "server",
    "media",
    "gaming",
    "office",
    "network",
    "security",
    "obsolete",
    "telemetry",
    "other",
)

# decisions.toml schema template for prompts
# fmt: off
DECISIONS_SCHEMA = """\
# decisions.toml Schema
# Generated by AI Advisor
# Date: {date}
# Provider: {provider}

[packages.apt]
keep = [
    {{ name = "pkg", reason = "why", confidence = 0.95, category = "system" }},
]
remove = [
    {{ name = "pkg", reason = "why", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "pkg", reason = "why", confidence = 0.45, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
"""
# fmt: on

# =============================================================================
# Headless Mode Prompt
# =============================================================================

# fmt: off
HEADLESS_PROMPT = """\
You are a Linux system administration expert helping classify packages \
on a Pop!_OS 24.04 system.

## Your Task

Read the scan.json file at `{scan_json_path}` and classify each package.
Write your decisions to `{decisions_output_path}` in TOML format.

## Context

- **OS**: Pop!_OS 24.04 LTS with COSMIC desktop
- **User profile**: Developer who uses containers for most work
- **Goal**: Identify packages that can be safely removed vs. must be kept
{system_context}

## Classification Rules

### 1. KEEP (confidence >= 0.9)
- System-critical packages (kernel, systemd, drivers)
- Libraries actively used by installed applications
- Hardware support (GPU, audio, network drivers)
- Desktop environment components (COSMIC, GNOME libraries)
- Essential development tools actively used

### 2. REMOVE (confidence >= 0.9)
- Packages for uninstalled applications (orphaned dependencies)
- Obsolete/deprecated packages no longer maintained
- Known bloatware or telemetry (apport, whoopsie, popularity-contest)
- Duplicate functionality (e.g., multiple editors when user prefers one)

### 3. ASK (confidence < 0.9)
- Packages with unclear purpose
- Development tools (user might need them)
- Optional features that may or may not be used
- Anything where you are uncertain

## Valid Categories

Use one of these categories for each package:
{categories}

## Output Format

Write a TOML file to `{decisions_output_path}` with this EXACT structure:

```toml
# Generated by AI Advisor
# Date: {timestamp}

[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU accel", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Dev tools", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Important Notes

1. Read the scan.json file completely before classifying
2. Be conservative - when in doubt, use "ask" instead of "remove"
3. Never recommend removing system-critical packages
4. Provide clear, concise reasons for each classification
5. Confidence should reflect your certainty (0.0 to 1.0)
6. The output file MUST be valid TOML syntax

## Begin Classification

Read `{scan_json_path}` and write your decisions to `{decisions_output_path}`.
"""
# fmt: on

# =============================================================================
# Interactive Mode Instructions
# =============================================================================

# fmt: off
INTERACTIVE_INSTRUCTIONS = """\
# Package Classification Task

You are helping to classify packages on a Pop!_OS 24.04 system.

## Files Available

| File | Description |
|------|-------------|
| `{scan_json_path}` | System scan data (packages to classify) |
| `{manifest_path}` | Current manifest (for reference) |

## Your Output

Write your classification decisions to: `{decisions_output_path}`

## Classification Guidelines

### KEEP (confidence >= 0.9)
- System-critical packages (kernel, systemd, cosmic-*, pop-*, drivers)
- Libraries needed by installed applications
- Hardware support packages
- Desktop environment components

### REMOVE (confidence >= 0.9)
- Orphaned dependencies (packages for removed apps)
- Obsolete/deprecated packages
- Known telemetry (apport, whoopsie, popularity-contest)

### ASK (confidence < 0.9)
- Unclear purpose
- Development tools (may or may not be needed)
- Optional features

## Output Format (decisions.toml)

```toml
# Generated by AI Advisor
# Date: {timestamp}

[packages.apt]
keep = [
    {{ name = "pkg", reason = "why", confidence = 0.95, category = "system" }},
]
remove = [
    {{ name = "pkg", reason = "why", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "pkg", reason = "why", confidence = 0.45, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Valid Categories

{categories}

## Workflow

1. Read the scan.json file to understand what packages are installed
2. Reference the manifest.toml to see what the user already tracks
3. Classify each package according to the guidelines
4. Write your decisions to the output file

## Important

- Be conservative: prefer "ask" over "remove" when uncertain
- Never remove packages matching: linux-*, systemd*, cosmic-*, pop-*, system76-*
- Provide clear reasons for each classification
- Output MUST be valid TOML syntax

When ready, ask any clarifying questions or proceed with classification.
"""
# fmt: on


def build_headless_prompt(
    scan_json_path: str,
    decisions_output_path: str,
    system_info: dict[str, str] | None = None,
) -> str:
    """Build prompt for headless (autonomous) classification.

    Constructs a complete prompt for the AI agent to perform autonomous
    package classification. The prompt includes paths to input/output files,
    classification rules, and output format specification.

    Args:
        scan_json_path: Path to scan.json file containing package data.
        decisions_output_path: Path where agent should write decisions.toml.
        system_info: Optional system context (hostname, os, machine_id).

    Returns:
        Complete prompt string for the AI agent.

    Example:
        >>> prompt = build_headless_prompt(
        ...     "/tmp/popctl-exchange/scan.json",
        ...     "/tmp/popctl-exchange/decisions.toml",
        ...     {"hostname": "pop-desktop", "os": "Pop!_OS 24.04"}
        ... )
    """
    # Build system context section
    system_context = ""
    if system_info:
        context_lines: list[str] = []
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
        if "machine_id" in system_info:
            context_lines.append(f"- **Machine ID**: {system_info['machine_id']}")
        if context_lines:
            system_context = "\n" + "\n".join(context_lines)

    # Format categories as bullet list
    categories_list = "\n".join(f"- {cat}" for cat in CATEGORIES)

    # Generate timestamp
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return HEADLESS_PROMPT.format(
        scan_json_path=scan_json_path,
        decisions_output_path=decisions_output_path,
        system_context=system_context,
        categories=categories_list,
        timestamp=timestamp,
    )


def build_interactive_instructions(
    scan_json_path: str,
    manifest_path: str,
    decisions_output_path: str,
) -> str:
    """Build instructions.md content for interactive mode.

    Creates a Markdown document that guides the AI agent through the
    interactive classification process. This is used when the user
    wants to supervise or collaborate with the agent.

    Args:
        scan_json_path: Path to scan.json file containing package data.
        manifest_path: Path to current manifest.toml for reference.
        decisions_output_path: Path for agent to write decisions.toml.

    Returns:
        Markdown content for instructions.md.

    Example:
        >>> instructions = build_interactive_instructions(
        ...     "/tmp/popctl-exchange/scan.json",
        ...     "~/.config/popctl/manifest.toml",
        ...     "/tmp/popctl-exchange/decisions.toml"
        ... )
    """
    # Format categories as comma-separated list for compact display
    categories_formatted = ", ".join(f"`{cat}`" for cat in CATEGORIES)

    # Generate timestamp
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return INTERACTIVE_INSTRUCTIONS.format(
        scan_json_path=scan_json_path,
        manifest_path=manifest_path,
        decisions_output_path=decisions_output_path,
        categories=categories_formatted,
        timestamp=timestamp,
    )


def get_decisions_schema(provider: str = "claude") -> str:
    """Get the decisions.toml schema template.

    Returns a template showing the expected format for decisions.toml
    output. Useful for documentation or validation reference.

    Args:
        provider: Provider name to include in schema header.

    Returns:
        Schema template string.
    """
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    return DECISIONS_SCHEMA.format(date=timestamp, provider=provider)


def get_prompt_file_path(exchange_dir: Path) -> Path:
    """Get the standard path for the prompt file in exchange directory.

    Args:
        exchange_dir: Exchange directory path.

    Returns:
        Path to prompt.txt in the exchange directory.
    """
    return exchange_dir / "prompt.txt"


def get_instructions_file_path(exchange_dir: Path) -> Path:
    """Get the standard path for instructions.md in exchange directory.

    Args:
        exchange_dir: Exchange directory path.

    Returns:
        Path to instructions.md in the exchange directory.
    """
    return exchange_dir / "instructions.md"
