"""Prompt templates for AI-assisted package classification.

This module provides prompt templates for the Claude Advisor to classify
packages as keep, remove, or ask. It supports headless (autonomous) mode
and workspace-based interactive sessions via CLAUDE.md.

Templates encode classification rules for protected packages, confidence
thresholds, valid categories, and output format (decisions.toml).
"""

from datetime import UTC, datetime
from pathlib import Path

# =============================================================================
# decisions.toml Schema Reference
# =============================================================================
# The expected output format for AI classification:
#
# [packages.apt]
# keep = [
#     { name = "pkg", reason = "...", confidence = 0.95, category = "system" },
# ]
# remove = [
#     { name = "pkg", reason = "...", confidence = 0.92, category = "telemetry" },
# ]
# ask = [
#     { name = "pkg", reason = "...", confidence = 0.45, category = "development" },
# ]
#
# [packages.flatpak]
# keep = []
# remove = []
# ask = []
# =============================================================================

# Classification categories for packages
CATEGORIES = (
    "system",
    "desktop",
    "drivers",
    "development",
    "server",
    "media",
    "gaming",
    "office",
    "network",
    "security",
    "obsolete",
    "telemetry",
    "other",
)

# decisions.toml schema template for prompts
# fmt: off
DECISIONS_SCHEMA = """\
# decisions.toml Schema
# Generated by AI Advisor
# Date: {date}
# Provider: {provider}

[packages.apt]
keep = [
    {{ name = "pkg", reason = "why", confidence = 0.95, category = "system" }},
]
remove = [
    {{ name = "pkg", reason = "why", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "pkg", reason = "why", confidence = 0.45, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
"""
# fmt: on

# =============================================================================
# Headless Mode Prompt
# =============================================================================

# fmt: off
HEADLESS_PROMPT = """\
You are a Linux system administration expert helping classify packages \
on a Pop!_OS 24.04 system.

## Your Task

Read the scan.json file at `{scan_json_path}` and classify each package.
Write your decisions to `{decisions_output_path}` in TOML format.

## Context

- **OS**: Pop!_OS 24.04 LTS with COSMIC desktop
- **User profile**: Developer who uses containers for all development work
- **Goal**: Achieve a maximally lean, minimally invasive host system
- **Philosophy**: The host provides only the OS, desktop, drivers, and
  container runtime. All development tools, compilers, interpreters,
  and build dependencies belong inside dev-containers, NOT on the host.
{system_context}

## Classification Rules

### 1. KEEP (confidence >= 0.9)
- System-critical packages (kernel, systemd, drivers)
- Libraries required by installed desktop applications
- Hardware support (GPU, audio, network, bluetooth drivers)
- Desktop environment components (COSMIC, GNOME libraries)
- Container runtime and tooling (docker, podman)

### 2. REMOVE (confidence >= 0.9)
- Development tools and compilers (gcc, make, *-dev headers) —
  these belong in containers
- Packages for uninstalled applications (orphaned dependencies)
- Obsolete/deprecated packages no longer maintained
- Known bloatware or telemetry (apport, whoopsie, popularity-contest)
- Duplicate functionality (e.g., multiple editors, redundant utilities)
- Server software not needed on a desktop (apache, nginx, postfix)
- Printer drivers if no printer is connected

### 3. ASK (confidence < 0.9)
- Packages where the removal impact is unclear
- Libraries that MIGHT be needed by installed desktop apps
- Optional desktop features (accessibility, input methods)
- Anything where you are uncertain

## Valid Categories

Use one of these categories for each package:
{categories}

## Output Format

Write a TOML file to `{decisions_output_path}` with this EXACT structure:

```toml
# Generated by AI Advisor
# Date: {timestamp}

[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU accel", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Dev tools", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Important Notes

1. Read the scan.json file completely before classifying
2. Lean towards removal — if a package is not clearly needed on the host,
   recommend removal. Use "ask" only when removal impact is genuinely unclear.
3. Never recommend removing system-critical or protected packages
4. Provide clear, concise reasons for each classification
5. Confidence should reflect your certainty (0.0 to 1.0)
6. The output file MUST be valid TOML syntax

## Begin Classification

Read `{scan_json_path}` and write your decisions to `{decisions_output_path}`.
"""
# fmt: on

# =============================================================================
# Session CLAUDE.md Template (auto-loaded by Claude Code from workspace CWD)
# =============================================================================

# fmt: off
SESSION_CLAUDE_MD = """\
# Interactive Package Classification

You are a Linux system administration expert helping the user classify
packages on a Pop!_OS 24.04 system. This is an **interactive session** —
you work together with the user, not autonomously.

## Context
{system_context}

## Design Philosophy

The user strives for a **maximally lean, minimally invasive host system**.
The host provides only: OS, desktop environment, hardware drivers, and
container runtime. All development tools, compilers, interpreters, and
build dependencies belong inside dev-containers, NOT on the host.

When in doubt, **lean towards removal** — the user prefers to discover
a missing package later and re-install it, rather than keeping unnecessary
packages on the host.

## Input Files

- `scan.json` — Package scan data (read this first)
- `manifest.toml` — Current manifest for reference (if present)

## Workflow (STRICT)

### Phase 1: Auto-classify obvious packages (SILENT)

Classify these packages automatically WITHOUT asking the user:

- **KEEP** (confidence >= 0.9): System-critical, protected, libraries
  required by installed desktop apps, hardware drivers, desktop environment
- **REMOVE** (confidence >= 0.9): Development tools and compilers
  (gcc, make, *-dev headers), known bloatware/telemetry (apport, whoopsie),
  orphaned dependencies, server software, printer drivers (no printer),
  clearly unnecessary packages for a lean desktop

### Phase 2: Discuss uncertain packages WITH the user

For ALL remaining packages (confidence < 0.9), present them to the user
**in groups by category**. For each group:

1. Show the category name and how many packages are in it
2. List each package with your recommendation and reasoning
3. Ask the user for their decision (keep / remove / skip)
4. Wait for the user's response before moving to the next group

**DO NOT auto-classify uncertain packages. ALWAYS ask.**

Your recommendation should reflect the lean-host philosophy: if a package
is not clearly needed for the desktop experience, recommend removal.

Example interaction:
```
### Entwicklungstools (8 Pakete)

Diese Pakete gehoeren typischerweise in Container, nicht auf den Host.

| Paket | Empfehlung | Grund |
|-------|-----------|-------|
| gcc-13 | entfernen | Compiler — gehoert in Container |
| make | entfernen | Build-Tool — gehoert in Container |
| libxml2-dev | entfernen | Header — nur fuer Kompilierung |
| ...   | ...       | ...   |

Einverstanden mit Entfernung aller? (ja/nein/Paketnamen behalten)
```

### Phase 3: Write decisions

After ALL groups have been discussed, write the collected decisions
to `output/decisions.toml`.

## Protected Packages (NEVER remove)

Packages matching these patterns must always be classified as KEEP:
`linux-*`, `systemd*`, `cosmic-*`, `pop-*`, `system76-*`, `grub-*`,
`apt*`, `dpkg*`, `flatpak`, `bash`, `coreutils`, `sudo`, `networkmanager*`

## Valid Categories

{categories}

## Output Format (output/decisions.toml)

```toml
[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU acceleration", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Crash telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Development tool", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Rules

1. Read `scan.json` completely before starting
2. Lean towards removal — if not clearly needed on the host, recommend removal
3. Use "ask" only when the impact of removal is genuinely unclear
4. Never remove protected packages
5. Confidence reflects your certainty (0.0 to 1.0)
6. Output MUST be valid TOML syntax
7. **NEVER write decisions.toml before finishing all discussions with the user**
"""
# fmt: on

# Initial prompt sent to Claude Code when starting an interactive session.
# Instructs a collaborative workflow: auto-classify obvious packages,
# discuss uncertain ones step by step with the user.
INITIAL_PROMPT = (
    "Lies scan.json und CLAUDE.md. "
    "Klassifiziere offensichtliche Pakete (Confidence >= 0.9) automatisch. "
    "Alle anderen Pakete besprichst du mit mir schrittweise — "
    "zeige jeweils den Paketnamen, deine Einschätzung und frage nach meiner Entscheidung. "
    "Am Ende schreibst du die gesammelten Entscheidungen in output/decisions.toml."
)


def build_headless_prompt(
    scan_json_path: str,
    decisions_output_path: str,
    system_info: dict[str, str] | None = None,
) -> str:
    """Build prompt for headless (autonomous) classification.

    Constructs a complete prompt for the AI agent to perform autonomous
    package classification. The prompt includes paths to input/output files,
    classification rules, and output format specification.

    Args:
        scan_json_path: Path to scan.json file containing package data.
        decisions_output_path: Path where agent should write decisions.toml.
        system_info: Optional system context (hostname, os, machine_id).

    Returns:
        Complete prompt string for the AI agent.

    Example:
        >>> prompt = build_headless_prompt(
        ...     "/tmp/popctl-exchange/scan.json",
        ...     "/tmp/popctl-exchange/decisions.toml",
        ...     {"hostname": "pop-desktop", "os": "Pop!_OS 24.04"}
        ... )
    """
    # Build system context section
    system_context = ""
    if system_info:
        context_lines: list[str] = []
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
        if "machine_id" in system_info:
            context_lines.append(f"- **Machine ID**: {system_info['machine_id']}")
        if context_lines:
            system_context = "\n" + "\n".join(context_lines)

    # Format categories as bullet list
    categories_list = "\n".join(f"- {cat}" for cat in CATEGORIES)

    # Generate timestamp
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return HEADLESS_PROMPT.format(
        scan_json_path=scan_json_path,
        decisions_output_path=decisions_output_path,
        system_context=system_context,
        categories=categories_list,
        timestamp=timestamp,
    )


def build_session_claude_md(
    system_info: dict[str, str] | None = None,
    summary: dict[str, int] | None = None,
) -> str:
    """Build CLAUDE.md content for an interactive session workspace.

    Creates a comprehensive CLAUDE.md file that Claude Code picks up
    automatically from the working directory. Contains classification
    rules, output format, and system context.

    Args:
        system_info: Optional system context (hostname, os).
        summary: Optional package count summary (total, manual, auto).

    Returns:
        CLAUDE.md content string.
    """
    # Build system context section
    context_lines: list[str] = []
    if system_info:
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
    if summary:
        if "total" in summary:
            context_lines.append(f"- **Total packages scanned**: {summary['total']}")
        if "manual" in summary:
            context_lines.append(f"- **Manually installed**: {summary['manual']}")

    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    context_lines.append(f"- **Scan date**: {timestamp}")

    system_context = "\n".join(context_lines) if context_lines else "No system context available."

    # Format categories as bullet list
    categories_list = "\n".join(f"- `{cat}`" for cat in CATEGORIES)

    return SESSION_CLAUDE_MD.format(
        system_context=system_context,
        categories=categories_list,
    )


def build_initial_prompt() -> str:
    """Get the initial prompt for interactive Claude Code sessions.

    Returns:
        Short German prompt to kick off the classification conversation.
    """
    return INITIAL_PROMPT


def get_decisions_schema(provider: str = "claude") -> str:
    """Get the decisions.toml schema template.

    Returns a template showing the expected format for decisions.toml
    output. Useful for documentation or validation reference.

    Args:
        provider: Provider name to include in schema header.

    Returns:
        Schema template string.
    """
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    return DECISIONS_SCHEMA.format(date=timestamp, provider=provider)


def get_prompt_file_path(exchange_dir: Path) -> Path:
    """Get the standard path for the prompt file in exchange directory.

    Args:
        exchange_dir: Exchange directory path.

    Returns:
        Path to prompt.txt in the exchange directory.
    """
    return exchange_dir / "prompt.txt"
