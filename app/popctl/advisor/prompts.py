"""Prompt templates for AI-assisted package classification.

This module provides prompt templates for the Claude Advisor to classify
packages as keep, remove, or ask. It supports headless (autonomous) mode
and workspace-based interactive sessions via CLAUDE.md.

Templates encode classification rules for protected packages, confidence
thresholds, valid categories, and output format (decisions.toml).
"""

from datetime import UTC, datetime
from pathlib import Path

# =============================================================================
# decisions.toml Schema Reference
# =============================================================================
# The expected output format for AI classification:
#
# [packages.apt]
# keep = [
#     { name = "pkg", reason = "...", confidence = 0.95, category = "system" },
# ]
# remove = [
#     { name = "pkg", reason = "...", confidence = 0.92, category = "telemetry" },
# ]
# ask = [
#     { name = "pkg", reason = "...", confidence = 0.45, category = "development" },
# ]
#
# [packages.flatpak]
# keep = []
# remove = []
# ask = []
# =============================================================================

# Classification categories for packages
CATEGORIES = (
    "system",
    "desktop",
    "drivers",
    "development",
    "server",
    "media",
    "gaming",
    "office",
    "network",
    "security",
    "obsolete",
    "telemetry",
    "other",
)

# decisions.toml schema template for prompts
# fmt: off
DECISIONS_SCHEMA = """\
# decisions.toml Schema
# Generated by AI Advisor
# Date: {date}
# Provider: {provider}

[packages.apt]
keep = [
    {{ name = "pkg", reason = "why", confidence = 0.95, category = "system" }},
]
remove = [
    {{ name = "pkg", reason = "why", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "pkg", reason = "why", confidence = 0.45, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
"""
# fmt: on

# =============================================================================
# Headless Mode Prompt
# =============================================================================

# fmt: off
HEADLESS_PROMPT = """\
You are a Linux system administration expert helping classify packages \
on a Pop!_OS 24.04 system.

## Your Task

Read the scan.json file at `{scan_json_path}` and classify each package.
Write your decisions to `{decisions_output_path}` in TOML format.

## Context

- **OS**: Pop!_OS 24.04 LTS with COSMIC desktop
- **User profile**: Developer who uses containers for all development work
- **Goal**: Achieve a maximally lean, minimally invasive host system
- **Philosophy**: The host provides only the OS, desktop, drivers, and
  container runtime. All development tools, compilers, interpreters,
  and build dependencies belong inside dev-containers, NOT on the host.
- If `memory.md` exists in the working directory, read it first and use
  prior user decisions to pre-classify packages with higher confidence.
{system_context}

## Classification Rules

### 1. KEEP (confidence >= 0.9)
- System-critical packages (kernel, systemd, drivers)
- Libraries required by installed desktop applications
- Hardware support (GPU, audio, network, bluetooth drivers)
- Desktop environment components (COSMIC, GNOME libraries)
- Container runtime and tooling (docker, podman)

### 2. REMOVE (confidence >= 0.9)
- Development tools and compilers (gcc, make, *-dev headers) —
  these belong in containers
- Packages for uninstalled applications (orphaned dependencies)
- Obsolete/deprecated packages no longer maintained
- Known bloatware or telemetry (apport, whoopsie, popularity-contest)
- Duplicate functionality (e.g., multiple editors, redundant utilities)
- Server software not needed on a desktop (apache, nginx, postfix)
- Printer drivers if no printer is connected

### 3. ASK (confidence < 0.9)
- Packages where the removal impact is unclear
- Libraries that MIGHT be needed by installed desktop apps
- Optional desktop features (accessibility, input methods)
- Anything where you are uncertain

## Valid Categories

Use one of these categories for each package:
{categories}

## Output Format

Write a TOML file to `{decisions_output_path}` with this EXACT structure:

```toml
# Generated by AI Advisor
# Date: {timestamp}

[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU accel", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Dev tools", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Important Notes

1. Read the scan.json file and memory.md (if present) completely before classifying
2. Lean towards removal — if a package is not clearly needed on the host,
   recommend removal. Use "ask" only when removal impact is genuinely unclear.
3. Never recommend removing system-critical or protected packages
4. Provide clear, concise reasons for each classification
5. Confidence should reflect your certainty (0.0 to 1.0)
6. The output file MUST be valid TOML syntax

## Begin Classification

Read `{scan_json_path}` and write your decisions to `{decisions_output_path}`.
"""
# fmt: on

# =============================================================================
# Session CLAUDE.md Template (auto-loaded by Claude Code from workspace CWD)
# =============================================================================

# fmt: off
SESSION_CLAUDE_MD = """\
# Interaktive Paket-Klassifikation

You are a Linux system administration expert helping the user classify
packages on a Pop!_OS 24.04 system. This is an **interactive session** —
you work together with the user, not autonomously.

## Context
{system_context}

## Design Philosophy

The user strives for a **maximally lean, minimally invasive host system**.
The host provides only: OS, desktop environment, hardware drivers, and
container runtime. All development tools, compilers, interpreters, and
build dependencies belong inside dev-containers, NOT on the host.

When in doubt, **lean towards removal** — the user prefers to discover
a missing package later and re-install it, rather than keeping unnecessary
packages on the host.

## Input Files

- `scan.json` — Package scan data (read this first)
- `manifest.toml` — Current manifest for reference (if present)
- `memory.md` — Past session decisions and user preferences (if present)

## Workflow (STRICT — follow phases in order)

### Phase 0: Agenda

1. Read `scan.json` completely
2. If `memory.md` exists, read it to learn prior user decisions
3. Greet the user briefly in German
4. Present a short agenda:
   - Total package count from scan
   - Estimated auto-classifiable count (confidence >= 0.9)
   - Estimated packages requiring user input
   - If memory.md had relevant prior decisions, mention how many packages
     can be pre-classified from memory
5. Wait for user acknowledgment before proceeding

### Phase 1: Auto-classify obvious packages (SILENT)

Classify these packages automatically WITHOUT asking the user:

- **KEEP** (confidence >= 0.9): System-critical, protected, libraries
  required by installed desktop apps, hardware drivers, desktop environment
- **REMOVE** (confidence >= 0.9): Development tools and compilers
  (gcc, make, *-dev headers), known bloatware/telemetry (apport, whoopsie),
  orphaned dependencies, server software, printer drivers (no printer),
  clearly unnecessary packages for a lean desktop
- **Memory-based**: Packages with prior decisions in `memory.md` —
  classify according to the stored decision (unless context has changed)

### Phase 2: Present Auto-classified Results

Present the results of Phase 1 to the user:

- **KEEP**: Show summary count only, offer opt-in drill-down.
  Example: "84 Pakete → KEEP (System, Desktop, Treiber). Liste sehen?"
- **REMOVE**: List ALL packages marked for removal with brief reason.
  Present as a table: | Paket | Grund | Kategorie |
- **Memory-based**: Mention how many were pre-classified from memory.

Ask the user to **confirm or adjust** before proceeding.
The user may:
- Confirm all ("Passt so")
- Move specific packages between categories ("Behalte X, entferne Y")
- Request the full KEEP list for review

**DO NOT proceed to Phase 3 until the user has confirmed.**

### Phase 3: Interactive Triage (AskUserQuestion)

For ALL remaining uncertain packages (confidence < 0.9, not covered by
memory), use the **AskUserQuestion** tool to present them to the user.

**Batching**: Present up to 4 packages per AskUserQuestion call.
Each question should contain:
- Package name and brief description of what it does
- Your recommendation with reasoning
- Question format: "[package]: [description]. Empfehlung: [action]. [reason]"

**Options per question** (exactly 3):
1. "Behalten" — Keep the package
2. "Entfernen" — Remove the package
3. "Diskutieren" — Discuss further in Phase 4

Group packages by category when batching (e.g., 4 development tools
together, then 4 media packages, etc.).

Collect all "Diskutieren" responses for Phase 4.

### Phase 4: Deep-Dive Discussion

For each package the user marked as "Diskutieren" in Phase 3:

**DO NOT use AskUserQuestion here. Use free-form conversation.**

For each package, provide:
1. Detailed description — what the package does, who uses it
2. Dependencies — what it pulls in, what depends on it
3. Impact assessment — what breaks if removed
4. Clear recommendation with confidence level
5. Answer any follow-up questions from the user

After discussing each package, ask for the user's final decision
(keep or remove) before moving to the next package.

### Phase 5: Write Artifact + Session Close

1. Write ALL collected decisions to `output/decisions.toml`
2. Update `memory.md` with new decisions and any learned preferences:
   - Add/update entries in the Known Decisions section
   - Note any new user preferences discovered during the session
   - Remove entries for packages no longer present in the scan
   - Keep the file concise — summarize categories with 20+ entries
3. Present a final summary table:
   - Total KEEP count
   - Total REMOVE count
   - Packages discussed in detail
4. Print: "**Session abgeschlossen.** Die Entscheidungen wurden in \
`output/decisions.toml` geschrieben. Du kannst die Session jetzt schliessen."

## Memory File Format (memory.md)

If `memory.md` does not exist, create it at the end of the session.
If it exists, update it. Structure:

```markdown
# Advisor Memory

## User Preferences
- [learned preferences, e.g., "User removes all dev tools from host"]

## Known Decisions
### Keep
- package-name: reason (YYYY-MM-DD)

### Remove
- package-name: reason (YYYY-MM-DD)

## Notes
- [any other context that helps future classifications]
```

## Protected Packages (NEVER remove)

Packages matching these patterns must always be classified as KEEP:
`linux-*`, `systemd*`, `cosmic-*`, `pop-*`, `system76-*`, `grub-*`,
`apt*`, `dpkg*`, `flatpak`, `bash`, `coreutils`, `sudo`, `networkmanager*`

## Valid Categories

{categories}

## Output Format (output/decisions.toml)

```toml
[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU acceleration", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Crash telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Development tool", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Rules

1. Read `scan.json` and `memory.md` (if present) completely before starting
2. Lean towards removal — if not clearly needed on the host, recommend removal
3. The `ask` list in decisions.toml should be EMPTY after an interactive session
   — all packages must be resolved to keep or remove through discussion
4. Never remove protected packages
5. Confidence reflects your certainty (0.0 to 1.0)
6. Output MUST be valid TOML syntax
7. **NEVER write decisions.toml before finishing ALL discussions with the user**
8. **ALWAYS update memory.md at the end of the session**
"""
# fmt: on

# Initial prompt sent to Claude Code when starting an interactive session.
# Directs the agent to follow the phased workflow defined in CLAUDE.md.
INITIAL_PROMPT = (
    "Lies scan.json, CLAUDE.md und memory.md (falls vorhanden). "
    "Beginne mit Phase 0: Stelle dich kurz vor und praesentiere die Agenda. "
    "Folge dann dem Workflow in CLAUDE.md strikt — Phase fuer Phase."
)


def build_headless_prompt(
    scan_json_path: str,
    decisions_output_path: str,
    system_info: dict[str, str] | None = None,
) -> str:
    """Build prompt for headless (autonomous) classification.

    Constructs a complete prompt for the AI agent to perform autonomous
    package classification. The prompt includes paths to input/output files,
    classification rules, and output format specification.

    Args:
        scan_json_path: Path to scan.json file containing package data.
        decisions_output_path: Path where agent should write decisions.toml.
        system_info: Optional system context (hostname, os, machine_id).

    Returns:
        Complete prompt string for the AI agent.

    Example:
        >>> prompt = build_headless_prompt(
        ...     "/tmp/popctl-exchange/scan.json",
        ...     "/tmp/popctl-exchange/decisions.toml",
        ...     {"hostname": "pop-desktop", "os": "Pop!_OS 24.04"}
        ... )
    """
    # Build system context section
    system_context = ""
    if system_info:
        context_lines: list[str] = []
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
        if "machine_id" in system_info:
            context_lines.append(f"- **Machine ID**: {system_info['machine_id']}")
        if context_lines:
            system_context = "\n" + "\n".join(context_lines)

    # Format categories as bullet list
    categories_list = "\n".join(f"- {cat}" for cat in CATEGORIES)

    # Generate timestamp
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return HEADLESS_PROMPT.format(
        scan_json_path=scan_json_path,
        decisions_output_path=decisions_output_path,
        system_context=system_context,
        categories=categories_list,
        timestamp=timestamp,
    )


def build_session_claude_md(
    system_info: dict[str, str] | None = None,
    summary: dict[str, int] | None = None,
) -> str:
    """Build CLAUDE.md content for an interactive session workspace.

    Creates a comprehensive CLAUDE.md file that Claude Code picks up
    automatically from the working directory. Contains classification
    rules, output format, and system context.

    Args:
        system_info: Optional system context (hostname, os).
        summary: Optional package count summary (total, manual, auto).

    Returns:
        CLAUDE.md content string.
    """
    # Build system context section
    context_lines: list[str] = []
    if system_info:
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
    if summary:
        if "total" in summary:
            context_lines.append(f"- **Total packages scanned**: {summary['total']}")
        if "manual" in summary:
            context_lines.append(f"- **Manually installed**: {summary['manual']}")

    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    context_lines.append(f"- **Scan date**: {timestamp}")

    system_context = "\n".join(context_lines) if context_lines else "No system context available."

    # Format categories as bullet list
    categories_list = "\n".join(f"- `{cat}`" for cat in CATEGORIES)

    return SESSION_CLAUDE_MD.format(
        system_context=system_context,
        categories=categories_list,
    )


def build_initial_prompt() -> str:
    """Get the initial prompt for interactive Claude Code sessions.

    Returns:
        Short German prompt to kick off the classification conversation.
    """
    return INITIAL_PROMPT


def get_decisions_schema(provider: str = "claude") -> str:
    """Get the decisions.toml schema template.

    Returns a template showing the expected format for decisions.toml
    output. Useful for documentation or validation reference.

    Args:
        provider: Provider name to include in schema header.

    Returns:
        Schema template string.
    """
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    return DECISIONS_SCHEMA.format(date=timestamp, provider=provider)


def get_prompt_file_path(exchange_dir: Path) -> Path:
    """Get the standard path for the prompt file in exchange directory.

    Args:
        exchange_dir: Exchange directory path.

    Returns:
        Path to prompt.txt in the exchange directory.
    """
    return exchange_dir / "prompt.txt"
