"""Prompt templates for AI-assisted package classification.

This module provides prompt templates for the Claude Advisor to classify
packages as keep, remove, or ask. It supports headless (autonomous) mode
and workspace-based interactive sessions via CLAUDE.md.

Templates encode classification rules for protected packages, confidence
thresholds, valid categories, and output format (decisions.toml).
"""

from datetime import UTC, datetime
from pathlib import Path

# =============================================================================
# decisions.toml Schema Reference
# =============================================================================
# The expected output format for AI classification:
#
# [packages.apt]
# keep = [
#     { name = "pkg", reason = "...", confidence = 0.95, category = "system" },
# ]
# remove = [
#     { name = "pkg", reason = "...", confidence = 0.92, category = "telemetry" },
# ]
# ask = [
#     { name = "pkg", reason = "...", confidence = 0.45, category = "development" },
# ]
#
# [packages.flatpak]
# keep = []
# remove = []
# ask = []
# =============================================================================

# Classification categories for packages
CATEGORIES = (
    "system",
    "desktop",
    "drivers",
    "development",
    "server",
    "media",
    "gaming",
    "office",
    "network",
    "security",
    "obsolete",
    "telemetry",
    "other",
)

# decisions.toml schema template for prompts
# fmt: off
DECISIONS_SCHEMA = """\
# decisions.toml Schema
# Generated by AI Advisor
# Date: {date}
# Provider: {provider}

[packages.apt]
keep = [
    {{ name = "pkg", reason = "why", confidence = 0.95, category = "system" }},
]
remove = [
    {{ name = "pkg", reason = "why", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "pkg", reason = "why", confidence = 0.45, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
"""
# fmt: on

# =============================================================================
# Headless Mode Prompt
# =============================================================================

# fmt: off
HEADLESS_PROMPT = """\
You are a Linux system administration expert helping classify packages \
on a Pop!_OS 24.04 system.

## Your Task

Read the scan.json file at `{scan_json_path}` and classify each package.
Write your decisions to `{decisions_output_path}` in TOML format.

## Context

- **OS**: Pop!_OS 24.04 LTS with COSMIC desktop
- **User profile**: Developer who uses containers for most work
- **Goal**: Identify packages that can be safely removed vs. must be kept
{system_context}

## Classification Rules

### 1. KEEP (confidence >= 0.9)
- System-critical packages (kernel, systemd, drivers)
- Libraries actively used by installed applications
- Hardware support (GPU, audio, network drivers)
- Desktop environment components (COSMIC, GNOME libraries)
- Essential development tools actively used

### 2. REMOVE (confidence >= 0.9)
- Packages for uninstalled applications (orphaned dependencies)
- Obsolete/deprecated packages no longer maintained
- Known bloatware or telemetry (apport, whoopsie, popularity-contest)
- Duplicate functionality (e.g., multiple editors when user prefers one)

### 3. ASK (confidence < 0.9)
- Packages with unclear purpose
- Development tools (user might need them)
- Optional features that may or may not be used
- Anything where you are uncertain

## Valid Categories

Use one of these categories for each package:
{categories}

## Output Format

Write a TOML file to `{decisions_output_path}` with this EXACT structure:

```toml
# Generated by AI Advisor
# Date: {timestamp}

[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU accel", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Dev tools", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Important Notes

1. Read the scan.json file completely before classifying
2. Be conservative - when in doubt, use "ask" instead of "remove"
3. Never recommend removing system-critical packages
4. Provide clear, concise reasons for each classification
5. Confidence should reflect your certainty (0.0 to 1.0)
6. The output file MUST be valid TOML syntax

## Begin Classification

Read `{scan_json_path}` and write your decisions to `{decisions_output_path}`.
"""
# fmt: on

# =============================================================================
# Session CLAUDE.md Template (auto-loaded by Claude Code from workspace CWD)
# =============================================================================

# fmt: off
SESSION_CLAUDE_MD = """\
# Interactive Package Classification

You are a Linux system administration expert helping the user classify
packages on a Pop!_OS 24.04 system. This is an **interactive session** —
you work together with the user, not autonomously.

## Context
{system_context}

## Input Files

- `scan.json` — Package scan data (read this first)
- `manifest.toml` — Current manifest for reference (if present)

## Workflow (STRICT)

### Phase 1: Auto-classify obvious packages (SILENT)

Classify these packages automatically WITHOUT asking the user:

- **KEEP** (confidence >= 0.9): System-critical, protected, active libraries,
  hardware drivers, desktop environment components
- **REMOVE** (confidence >= 0.9): Known bloatware/telemetry (apport, whoopsie,
  popularity-contest), clearly orphaned dependencies

### Phase 2: Discuss uncertain packages WITH the user

For ALL remaining packages (confidence < 0.9), present them to the user
**in groups by category**. For each group:

1. Show the category name and how many packages are in it
2. List each package with your assessment and reasoning
3. Ask the user for their decision (keep / remove / skip)
4. Wait for the user's response before moving to the next group

**DO NOT auto-classify uncertain packages. ALWAYS ask.**

Example interaction:
```
### Entwicklungstools (8 Pakete)

| Paket | Einschätzung | Grund |
|-------|-------------|-------|
| gcc-13 | unsicher | Compiler, wird evtl. im Container genutzt |
| make | unsicher | Build-Tool, oft mit gcc zusammen |
| ...   | ...         | ...   |

Welche davon möchtest du behalten? (alle/keine/Paketnamen)
```

### Phase 3: Write decisions

After ALL groups have been discussed, write the collected decisions
to `output/decisions.toml`.

## Protected Packages (NEVER remove)

Packages matching these patterns must always be classified as KEEP:
`linux-*`, `systemd*`, `cosmic-*`, `pop-*`, `system76-*`, `grub-*`,
`apt*`, `dpkg*`, `flatpak`, `bash`, `coreutils`, `sudo`, `networkmanager*`

## Valid Categories

{categories}

## Output Format (output/decisions.toml)

```toml
[packages.apt]
keep = [
    {{ name = "libvdpau1", reason = "GPU acceleration", confidence = 0.95, category = "drivers" }},
]
remove = [
    {{ name = "apport", reason = "Crash telemetry", confidence = 0.92, category = "telemetry" }},
]
ask = [
    {{ name = "gcc", reason = "Development tool", confidence = 0.65, category = "development" }},
]

[packages.flatpak]
keep = []
remove = []
ask = []
```

## Rules

1. Read `scan.json` completely before starting
2. Be conservative — prefer "ask" over "remove" when uncertain
3. Never remove protected packages
4. Confidence reflects your certainty (0.0 to 1.0)
5. Output MUST be valid TOML syntax
6. **NEVER write decisions.toml before finishing all discussions with the user**
"""
# fmt: on

# Initial prompt sent to Claude Code when starting an interactive session.
# Instructs a collaborative workflow: auto-classify obvious packages,
# discuss uncertain ones step by step with the user.
INITIAL_PROMPT = (
    "Lies scan.json und CLAUDE.md. "
    "Klassifiziere offensichtliche Pakete (Confidence >= 0.9) automatisch. "
    "Alle anderen Pakete besprichst du mit mir schrittweise — "
    "zeige jeweils den Paketnamen, deine Einschätzung und frage nach meiner Entscheidung. "
    "Am Ende schreibst du die gesammelten Entscheidungen in output/decisions.toml."
)


def build_headless_prompt(
    scan_json_path: str,
    decisions_output_path: str,
    system_info: dict[str, str] | None = None,
) -> str:
    """Build prompt for headless (autonomous) classification.

    Constructs a complete prompt for the AI agent to perform autonomous
    package classification. The prompt includes paths to input/output files,
    classification rules, and output format specification.

    Args:
        scan_json_path: Path to scan.json file containing package data.
        decisions_output_path: Path where agent should write decisions.toml.
        system_info: Optional system context (hostname, os, machine_id).

    Returns:
        Complete prompt string for the AI agent.

    Example:
        >>> prompt = build_headless_prompt(
        ...     "/tmp/popctl-exchange/scan.json",
        ...     "/tmp/popctl-exchange/decisions.toml",
        ...     {"hostname": "pop-desktop", "os": "Pop!_OS 24.04"}
        ... )
    """
    # Build system context section
    system_context = ""
    if system_info:
        context_lines: list[str] = []
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
        if "machine_id" in system_info:
            context_lines.append(f"- **Machine ID**: {system_info['machine_id']}")
        if context_lines:
            system_context = "\n" + "\n".join(context_lines)

    # Format categories as bullet list
    categories_list = "\n".join(f"- {cat}" for cat in CATEGORIES)

    # Generate timestamp
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    return HEADLESS_PROMPT.format(
        scan_json_path=scan_json_path,
        decisions_output_path=decisions_output_path,
        system_context=system_context,
        categories=categories_list,
        timestamp=timestamp,
    )


def build_session_claude_md(
    system_info: dict[str, str] | None = None,
    summary: dict[str, int] | None = None,
) -> str:
    """Build CLAUDE.md content for an interactive session workspace.

    Creates a comprehensive CLAUDE.md file that Claude Code picks up
    automatically from the working directory. Contains classification
    rules, output format, and system context.

    Args:
        system_info: Optional system context (hostname, os).
        summary: Optional package count summary (total, manual, auto).

    Returns:
        CLAUDE.md content string.
    """
    # Build system context section
    context_lines: list[str] = []
    if system_info:
        if "hostname" in system_info:
            context_lines.append(f"- **Hostname**: {system_info['hostname']}")
        if "os" in system_info:
            context_lines.append(f"- **OS Version**: {system_info['os']}")
    if summary:
        if "total" in summary:
            context_lines.append(f"- **Total packages scanned**: {summary['total']}")
        if "manual" in summary:
            context_lines.append(f"- **Manually installed**: {summary['manual']}")

    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    context_lines.append(f"- **Scan date**: {timestamp}")

    system_context = "\n".join(context_lines) if context_lines else "No system context available."

    # Format categories as bullet list
    categories_list = "\n".join(f"- `{cat}`" for cat in CATEGORIES)

    return SESSION_CLAUDE_MD.format(
        system_context=system_context,
        categories=categories_list,
    )


def build_initial_prompt() -> str:
    """Get the initial prompt for interactive Claude Code sessions.

    Returns:
        Short German prompt to kick off the classification conversation.
    """
    return INITIAL_PROMPT


def get_decisions_schema(provider: str = "claude") -> str:
    """Get the decisions.toml schema template.

    Returns a template showing the expected format for decisions.toml
    output. Useful for documentation or validation reference.

    Args:
        provider: Provider name to include in schema header.

    Returns:
        Schema template string.
    """
    timestamp = datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    return DECISIONS_SCHEMA.format(date=timestamp, provider=provider)


def get_prompt_file_path(exchange_dir: Path) -> Path:
    """Get the standard path for the prompt file in exchange directory.

    Args:
        exchange_dir: Exchange directory path.

    Returns:
        Path to prompt.txt in the exchange directory.
    """
    return exchange_dir / "prompt.txt"
